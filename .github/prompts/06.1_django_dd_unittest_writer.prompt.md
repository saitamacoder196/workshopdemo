---
description: Generate comprehensive unit tests based on DD implementation plan from prompt 04
---

# Django Design Detail (DD) Unit Test Writer

This prompt analyzes the DD requirements and implementation plan from prompt 04 to generate comprehensive unit tests for all changes and additions. This is the first part of the testing workflow - writing the tests.

## Prerequisites

**Required Input:**
- 📋 **Implementation Plan**: Output from `04_django_dd_implementation_plan.prompt.md`
- 📁 **DD Requirements**: Original DD specification files
- 📦 **Project Name**: `${input:project_name}`
- 🏷️ **App Name**: `${input:app_name}`
- 📄 **Implementation Plan Path**: `${input:implementation_plan_path}`
- 📁 **DD Folder Path**: `${input:dd_folder_path}`

**Output Structure:**
This prompt follows the template defined in `.github/templates/output_templates.md` for Test Generation (Prompt 06.1).

**Output Folder:** `test_generation/`
**Main Output File:** `metadata/test_generation_summary.json`

## Unit Test Generation Workflow

### Step 1: Analyze DD Requirements and Changes

**Parse and analyze all changes from implementation plan:**

```bash
echo "=== ANALYZING DD REQUIREMENTS FOR TEST GENERATION ==="

# Extract key components from implementation plan
echo "Extracting implementation components..."

# Create test analysis directory
mkdir -p test_generation/{analysis,templates,generated_tests}

# Parse implementation plan
cat ${input:implementation_plan_path}/implementation_plan.json > test_generation/analysis/implementation_plan.json

echo "✅ Implementation plan loaded for test analysis"
```

**Generate test matrix based on DD requirements:**

```python
# File: test_generation/analysis/test_matrix_generator.py

"""
Test matrix generator for DD implementation
Auto-generated based on DD requirements analysis
"""

import json
from typing import Dict, List, Tuple
from datetime import datetime
from pathlib import Path

class DDTestMatrix:
    """Generate comprehensive test cases based on DD requirements"""
    
    def __init__(self, implementation_plan: Dict, app_name: str):
        self.implementation_plan = implementation_plan
        self.app_name = app_name
        self.dd_requirements = implementation_plan.get('dd_requirements', {})
        self.test_matrix = {
            'model_tests': [],
            'serializer_tests': [],
            'view_tests': [],
            'api_tests': [],
            'integration_tests': [],
            'business_logic_tests': []
        }
    
    def analyze_model_requirements(self) -> List[Dict]:
        """Generate test cases for models based on DD requirements"""
        test_cases = []
        
        models = self.dd_requirements.get('data_models', [])
        
        for model in models:
            model_name = model.get('name', '')
            fields = model.get('fields', {})
            
            # Basic model creation test
            test_cases.append({
                'test_name': f'test_{model_name.lower()}_creation',
                'test_type': 'model_creation',
                'model': model_name,
                'description': f'Test successful creation of {model_name} model',
                'test_data': {
                    'valid_data': self._generate_valid_model_data(fields),
                    'required_fields': [f for f, spec in fields.items() if spec.get('required', False)]
                }
            })
            
            # Field validation tests
            for field_name, field_spec in fields.items():
                # Required field tests
                if field_spec.get('required', False):
                    test_cases.append({
                        'test_name': f'test_{model_name.lower()}_requires_{field_name}',
                        'test_type': 'field_validation',
                        'model': model_name,
                        'field': field_name,
                        'description': f'Test that {field_name} is required for {model_name}',
                        'test_data': {
                            'field_name': field_name,
                            'validation_type': 'required'
                        }
                    })
                
                # Field constraint tests
                if 'min_value' in field_spec:
                    test_cases.append({
                        'test_name': f'test_{model_name.lower()}_{field_name}_min_value',
                        'test_type': 'field_validation',
                        'model': model_name,
                        'field': field_name,
                        'description': f'Test minimum value constraint for {field_name}',
                        'test_data': {
                            'field_name': field_name,
                            'min_value': field_spec['min_value'],
                            'validation_type': 'min_value'
                        }
                    })
                
                if 'max_length' in field_spec:
                    test_cases.append({
                        'test_name': f'test_{model_name.lower()}_{field_name}_max_length',
                        'test_type': 'field_validation',
                        'model': model_name,
                        'field': field_name,
                        'description': f'Test maximum length constraint for {field_name}',
                        'test_data': {
                            'field_name': field_name,
                            'max_length': field_spec['max_length'],
                            'validation_type': 'max_length'
                        }
                    })
                
                # Unique constraint tests
                if field_spec.get('unique', False):
                    test_cases.append({
                        'test_name': f'test_{model_name.lower()}_{field_name}_unique',
                        'test_type': 'field_validation',
                        'model': model_name,
                        'field': field_name,
                        'description': f'Test unique constraint for {field_name}',
                        'test_data': {
                            'field_name': field_name,
                            'validation_type': 'unique'
                        }
                    })
            
            # Model method tests (if specified in DD)
            model_methods = model.get('methods', [])
            for method in model_methods:
                test_cases.append({
                    'test_name': f'test_{model_name.lower()}_{method["name"]}',
                    'test_type': 'model_method',
                    'model': model_name,
                    'method': method['name'],
                    'description': f'Test {method["name"]} method of {model_name}',
                    'test_data': {
                        'method_name': method['name'],
                        'expected_behavior': method.get('description', '')
                    }
                })
        
        return test_cases
    
    def analyze_serializer_requirements(self) -> List[Dict]:
        """Generate test cases for serializers"""
        test_cases = []
        
        api_endpoints = self.dd_requirements.get('api_endpoints', [])
        
        for endpoint in api_endpoints:
            endpoint_name = endpoint.get('name', endpoint.get('path', '').replace('/', '_'))
            
            # Serialization tests
            test_cases.append({
                'test_name': f'test_{endpoint_name}_serialization',
                'test_type': 'serializer_output',
                'endpoint': endpoint_name,
                'description': f'Test serialization for {endpoint_name}',
                'test_data': {
                    'endpoint_path': endpoint.get('path', ''),
                    'response_fields': endpoint.get('response_fields', []),
                    'serializer_name': f'{endpoint_name.title()}Serializer'
                }
            })
            
            # Deserialization tests
            if endpoint.get('method', 'GET') in ['POST', 'PUT', 'PATCH']:
                test_cases.append({
                    'test_name': f'test_{endpoint_name}_deserialization',
                    'test_type': 'serializer_input',
                    'endpoint': endpoint_name,
                    'description': f'Test deserialization for {endpoint_name}',
                    'test_data': {
                        'endpoint_path': endpoint.get('path', ''),
                        'request_fields': endpoint.get('request_fields', []),
                        'required_fields': endpoint.get('required_fields', []),
                        'serializer_name': f'{endpoint_name.title()}Serializer'
                    }
                })
            
            # Validation tests
            validation_rules = endpoint.get('validation_rules', [])
            for rule in validation_rules:
                test_cases.append({
                    'test_name': f'test_{endpoint_name}_validation_{rule.get("field", "general")}',
                    'test_type': 'serializer_validation',
                    'endpoint': endpoint_name,
                    'description': f'Test validation rule: {rule.get("description", "")}',
                    'test_data': {
                        'validation_rule': rule,
                        'serializer_name': f'{endpoint_name.title()}Serializer'
                    }
                })
        
        return test_cases
    
    def analyze_view_requirements(self) -> List[Dict]:
        """Generate test cases for views/viewsets"""
        test_cases = []
        
        api_endpoints = self.dd_requirements.get('api_endpoints', [])
        
        for endpoint in api_endpoints:
            endpoint_name = endpoint.get('name', endpoint.get('path', '').replace('/', '_'))
            method = endpoint.get('method', 'GET')
            
            # Basic endpoint response test
            test_cases.append({
                'test_name': f'test_{endpoint_name}_{method.lower()}_response',
                'test_type': 'view_response',
                'endpoint': endpoint_name,
                'method': method,
                'description': f'Test {method} response for {endpoint_name}',
                'test_data': {
                    'endpoint_path': endpoint.get('path', ''),
                    'method': method,
                    'expected_status': endpoint.get('expected_status', 200),
                    'response_format': endpoint.get('response_format', 'JSON')
                }
            })
            
            # Authentication tests
            if endpoint.get('authentication_required', True):
                test_cases.append({
                    'test_name': f'test_{endpoint_name}_authentication_required',
                    'test_type': 'view_authentication',
                    'endpoint': endpoint_name,
                    'method': method,
                    'description': f'Test authentication requirement for {endpoint_name}',
                    'test_data': {
                        'endpoint_path': endpoint.get('path', ''),
                        'method': method,
                        'expected_unauthorized_status': 401
                    }
                })
            
            # Permission tests
            permissions = endpoint.get('permissions', [])
            for permission in permissions:
                test_cases.append({
                    'test_name': f'test_{endpoint_name}_{permission.replace(".", "_")}_permission',
                    'test_type': 'view_permission',
                    'endpoint': endpoint_name,
                    'method': method,
                    'description': f'Test {permission} permission for {endpoint_name}',
                    'test_data': {
                        'endpoint_path': endpoint.get('path', ''),
                        'method': method,
                        'permission': permission,
                        'expected_forbidden_status': 403
                    }
                })
            
            # Pagination tests (for list endpoints)
            if method == 'GET' and endpoint.get('supports_pagination', False):
                test_cases.append({
                    'test_name': f'test_{endpoint_name}_pagination',
                    'test_type': 'view_pagination',
                    'endpoint': endpoint_name,
                    'method': method,
                    'description': f'Test pagination for {endpoint_name}',
                    'test_data': {
                        'endpoint_path': endpoint.get('path', ''),
                        'page_size': endpoint.get('page_size', 20),
                        'pagination_style': endpoint.get('pagination_style', 'PageNumberPagination')
                    }
                })
        
        return test_cases
    
    def analyze_business_logic_requirements(self) -> List[Dict]:
        """Generate test cases for business logic"""
        test_cases = []
        
        business_rules = self.dd_requirements.get('business_rules', [])
        
        for rule in business_rules:
            rule_name = rule.get('name', '').replace(' ', '_').lower()
            
            test_cases.append({
                'test_name': f'test_business_rule_{rule_name}',
                'test_type': 'business_logic',
                'rule': rule_name,
                'description': f'Test business rule: {rule.get("description", "")}',
                'test_data': {
                    'rule_description': rule.get('description', ''),
                    'rule_conditions': rule.get('conditions', []),
                    'expected_behavior': rule.get('expected_behavior', ''),
                    'test_scenarios': rule.get('test_scenarios', [])
                }
            })
        
        return test_cases
    
    def _generate_valid_model_data(self, fields: Dict) -> Dict:
        """Generate valid test data for model fields"""
        valid_data = {}
        
        for field_name, field_spec in fields.items():
            field_type = field_spec.get('type', 'CharField')
            
            if field_type == 'CharField':
                valid_data[field_name] = 'test_string'
            elif field_type == 'IntegerField':
                valid_data[field_name] = 1
            elif field_type == 'BooleanField':
                valid_data[field_name] = True
            elif field_type == 'EmailField':
                valid_data[field_name] = 'test@example.com'
            elif field_type == 'DateTimeField':
                valid_data[field_name] = '2023-01-01T00:00:00Z'
            else:
                valid_data[field_name] = 'test_value'
        
        return valid_data
    
    def generate_complete_test_matrix(self) -> Dict:
        """Generate complete test matrix"""
        print("Generating test matrix...")
        
        self.test_matrix['model_tests'] = self.analyze_model_requirements()
        self.test_matrix['serializer_tests'] = self.analyze_serializer_requirements()
        self.test_matrix['view_tests'] = self.analyze_view_requirements()
        self.test_matrix['business_logic_tests'] = self.analyze_business_logic_requirements()
        
        # API integration tests (combining multiple components)
        self.test_matrix['api_tests'] = self._generate_api_integration_tests()
        
        # Integration tests (full workflow tests)
        self.test_matrix['integration_tests'] = self._generate_integration_tests()
        
        return self.test_matrix
    
    def _generate_api_integration_tests(self) -> List[Dict]:
        """Generate API integration tests"""
        test_cases = []
        
        api_endpoints = self.dd_requirements.get('api_endpoints', [])
        
        # CRUD workflow tests
        crud_endpoints = [ep for ep in api_endpoints if ep.get('method') in ['POST', 'GET', 'PUT', 'DELETE']]
        
        if crud_endpoints:
            test_cases.append({
                'test_name': 'test_crud_workflow',
                'test_type': 'api_integration',
                'description': 'Test complete CRUD workflow',
                'test_data': {
                    'endpoints': crud_endpoints,
                    'workflow': ['POST', 'GET', 'PUT', 'DELETE']
                }
            })
        
        return test_cases
    
    def _generate_integration_tests(self) -> List[Dict]:
        """Generate integration tests"""
        test_cases = []
        
        # End-to-end workflow tests based on DD scenarios
        scenarios = self.dd_requirements.get('test_scenarios', [])
        
        for scenario in scenarios:
            test_cases.append({
                'test_name': f'test_scenario_{scenario.get("name", "").replace(" ", "_").lower()}',
                'test_type': 'integration',
                'description': f'Test scenario: {scenario.get("description", "")}',
                'test_data': {
                    'scenario': scenario,
                    'steps': scenario.get('steps', []),
                    'expected_outcome': scenario.get('expected_outcome', '')
                }
            })
        
        return test_cases


def generate_test_matrix():
    """Main function to generate test matrix"""
    # Load implementation plan
    with open('test_generation/analysis/implementation_plan.json', 'r') as f:
        implementation_plan = json.load(f)
    
    generator = DDTestMatrix(implementation_plan, '${input:app_name}')
    test_matrix = generator.generate_complete_test_matrix()
    
    # Save test matrix
    with open('test_generation/analysis/test_matrix.json', 'w') as f:
        json.dump(test_matrix, f, indent=2)
    
    print(f"✅ Test matrix generated:")
    print(f"   - Model tests: {len(test_matrix['model_tests'])}")
    print(f"   - Serializer tests: {len(test_matrix['serializer_tests'])}")
    print(f"   - View tests: {len(test_matrix['view_tests'])}")
    print(f"   - API tests: {len(test_matrix['api_tests'])}")
    print(f"   - Integration tests: {len(test_matrix['integration_tests'])}")
    print(f"   - Business logic tests: {len(test_matrix['business_logic_tests'])}")
    
    return test_matrix


if __name__ == '__main__':
    generate_test_matrix()
```

### Step 2: Generate Test Templates

**Create reusable test templates for different test types:**

```python
# File: test_generation/templates/test_templates.py

"""
Reusable test templates for different types of tests
"""

from typing import Dict, List

class TestTemplates:
    """Collection of test templates for different test types"""
    
    @staticmethod
    def model_creation_test(test_data: Dict) -> str:
        """Generate model creation test"""
        model_name = test_data['model']
        valid_data = test_data['test_data']['valid_data']
        
        template = f'''
def test_{model_name.lower()}_creation(self):
    """Test successful creation of {model_name} model"""
    # Arrange
    valid_data = {valid_data}
    
    # Act
    instance = {model_name}.objects.create(**valid_data)
    
    # Assert
    self.assertIsNotNone(instance.id)
    self.assertEqual(instance.id, instance.pk)
    
    # Verify all fields were set correctly
    for field_name, expected_value in valid_data.items():
        actual_value = getattr(instance, field_name)
        self.assertEqual(actual_value, expected_value, 
                        f"{{field_name}} was not set correctly")
'''
        return template
    
    @staticmethod
    def field_validation_test(test_data: Dict) -> str:
        """Generate field validation test"""
        model_name = test_data['model']
        field_name = test_data['field']
        validation_type = test_data['test_data']['validation_type']
        
        if validation_type == 'required':
            template = f'''
def test_{model_name.lower()}_requires_{field_name}(self):
    """Test that {field_name} is required for {model_name}"""
    # Arrange
    data = self.get_valid_{model_name.lower()}_data()
    data.pop('{field_name}')  # Remove required field
    
    # Act & Assert
    with self.assertRaises(ValidationError):
        instance = {model_name}(**data)
        instance.full_clean()
'''
        
        elif validation_type == 'unique':
            template = f'''
def test_{model_name.lower()}_{field_name}_unique(self):
    """Test unique constraint for {field_name}"""
    # Arrange
    data = self.get_valid_{model_name.lower()}_data()
    {model_name}.objects.create(**data)
    
    # Act & Assert
    with self.assertRaises(IntegrityError):
        {model_name}.objects.create(**data)  # Same data should fail
'''
        
        elif validation_type == 'max_length':
            max_length = test_data['test_data']['max_length']
            template = f'''
def test_{model_name.lower()}_{field_name}_max_length(self):
    """Test maximum length constraint for {field_name}"""
    # Arrange
    data = self.get_valid_{model_name.lower()}_data()
    data['{field_name}'] = 'x' * ({max_length} + 1)  # Exceed max length
    
    # Act & Assert
    with self.assertRaises(ValidationError):
        instance = {model_name}(**data)
        instance.full_clean()
'''
        
        else:
            template = f'''
def test_{model_name.lower()}_{field_name}_validation(self):
    """Test validation for {field_name}"""
    # TODO: Implement specific validation test for {validation_type}
    pass
'''
        
        return template
    
    @staticmethod
    def serializer_test(test_data: Dict) -> str:
        """Generate serializer test"""
        serializer_name = test_data['test_data']['serializer_name']
        test_type = test_data['test_type']
        
        if test_type == 'serializer_output':
            response_fields = test_data['test_data']['response_fields']
            template = f'''
def test_{test_data["endpoint"].lower()}_serialization(self):
    """Test serialization for {test_data["endpoint"]}"""
    # Arrange
    instance = self.create_test_instance()
    serializer = {serializer_name}(instance)
    
    # Act
    data = serializer.data
    
    # Assert
    expected_fields = {response_fields}
    for field in expected_fields:
        self.assertIn(field, data, f"Field {{field}} missing from serialized data")
    
    # Verify data types and values
    self.assertIsInstance(data, dict)
    self.assertTrue(len(data) > 0)
'''
        
        elif test_type == 'serializer_input':
            request_fields = test_data['test_data']['request_fields']
            required_fields = test_data['test_data']['required_fields']
            template = f'''
def test_{test_data["endpoint"].lower()}_deserialization(self):
    """Test deserialization for {test_data["endpoint"]}"""
    # Arrange
    valid_data = self.get_valid_serializer_data()
    
    # Act
    serializer = {serializer_name}(data=valid_data)
    
    # Assert
    self.assertTrue(serializer.is_valid(), 
                   f"Serializer validation failed: {{serializer.errors}}")
    
    validated_data = serializer.validated_data
    
    # Verify required fields are present
    required_fields = {required_fields}
    for field in required_fields:
        self.assertIn(field, validated_data, 
                     f"Required field {{field}} missing from validated data")

def test_{test_data["endpoint"].lower()}_required_fields(self):
    """Test required fields validation"""
    required_fields = {required_fields}
    
    for field in required_fields:
        # Arrange
        data = self.get_valid_serializer_data()
        data.pop(field)  # Remove required field
        
        # Act
        serializer = {serializer_name}(data=data)
        
        # Assert
        self.assertFalse(serializer.is_valid())
        self.assertIn(field, serializer.errors)
'''
        
        else:
            template = f'''
def test_{test_data["test_name"]}(self):
    """Test {test_data["description"]}"""
    # TODO: Implement {test_type} test
    pass
'''
        
        return template
    
    @staticmethod
    def view_test(test_data: Dict) -> str:
        """Generate view test"""
        test_type = test_data['test_type']
        endpoint_path = test_data['test_data']['endpoint_path']
        method = test_data['test_data']['method']
        
        if test_type == 'view_response':
            expected_status = test_data['test_data']['expected_status']
            template = f'''
def test_{test_data["endpoint"].lower()}_{method.lower()}_response(self):
    """Test {method} response for {test_data["endpoint"]}"""
    # Arrange
    self.authenticate_user()  # Set up authentication if needed
    url = "{endpoint_path}"
    
    # Act
    response = self.client.{method.lower()}(url)
    
    # Assert
    self.assertEqual(response.status_code, {expected_status})
    
    # Verify response format
    if response.status_code == 200:
        self.assertEqual(response['Content-Type'], 'application/json')
        
        # Parse and verify JSON response
        data = response.json()
        self.assertIsInstance(data, (dict, list))
'''
        
        elif test_type == 'view_authentication':
            template = f'''
def test_{test_data["endpoint"].lower()}_authentication_required(self):
    """Test authentication requirement for {test_data["endpoint"]}"""
    # Arrange
    url = "{endpoint_path}"
    # Don't authenticate user
    
    # Act
    response = self.client.{method.lower()}(url)
    
    # Assert
    self.assertEqual(response.status_code, 401)
'''
        
        elif test_type == 'view_permission':
            permission = test_data['test_data']['permission']
            template = f'''
def test_{test_data["endpoint"].lower()}_{permission.replace(".", "_")}_permission(self):
    """Test {permission} permission for {test_data["endpoint"]}"""
    # Arrange
    user_without_permission = self.create_user_without_permission()
    self.client.force_authenticate(user=user_without_permission)
    url = "{endpoint_path}"
    
    # Act
    response = self.client.{method.lower()}(url)
    
    # Assert
    self.assertEqual(response.status_code, 403)
'''
        
        else:
            template = f'''
def test_{test_data["test_name"]}(self):
    """Test {test_data["description"]}"""
    # TODO: Implement {test_type} test
    pass
'''
        
        return template
    
    @staticmethod
    def business_logic_test(test_data: Dict) -> str:
        """Generate business logic test"""
        rule_description = test_data['test_data']['rule_description']
        
        template = f'''
def test_business_rule_{test_data["rule"]}(self):
    """Test business rule: {rule_description}"""
    # Arrange
    # Set up test data according to business rule conditions
    
    # Act
    # Execute the business logic
    
    # Assert
    # Verify the expected behavior occurs
    
    # TODO: Implement specific business rule test
    # Rule: {rule_description}
    pass
'''
        
        return template


def get_test_template(test_data: Dict) -> str:
    """Get appropriate test template based on test type"""
    test_type = test_data['test_type']
    
    if test_type == 'model_creation':
        return TestTemplates.model_creation_test(test_data)
    elif test_type == 'field_validation':
        return TestTemplates.field_validation_test(test_data)
    elif test_type.startswith('serializer'):
        return TestTemplates.serializer_test(test_data)
    elif test_type.startswith('view'):
        return TestTemplates.view_test(test_data)
    elif test_type == 'business_logic':
        return TestTemplates.business_logic_test(test_data)
    else:
        return f'''
def test_{test_data["test_name"]}(self):
    """Test {test_data["description"]}"""
    # TODO: Implement {test_type} test
    pass
'''
```

### Step 3: Generate Actual Test Files

**Generate actual Django test files based on test matrix:**

```python
# File: test_generation/test_file_generator.py

"""
Generate actual Django test files from test matrix
"""

import json
from pathlib import Path
from typing import Dict, List
from test_generation.templates.test_templates import get_test_template

class TestFileGenerator:
    """Generate Django test files from test matrix"""
    
    def __init__(self, app_name: str, test_matrix: Dict):
        self.app_name = app_name
        self.test_matrix = test_matrix
        self.test_dir = Path(f'tests/test_{app_name}')
        
        # Create test directory structure
        self.test_dir.mkdir(parents=True, exist_ok=True)
        (self.test_dir / '__init__.py').touch()
    
    def generate_model_tests(self):
        """Generate model test file"""
        model_tests = self.test_matrix.get('model_tests', [])
        
        if not model_tests:
            return
        
        test_content = '''"""
Model tests for {app_name}
Auto-generated from DD requirements
"""

from django.test import TestCase
from django.core.exceptions import ValidationError
from django.db import IntegrityError
from apps.{app_name}.models import *


class ModelTests(TestCase):
    """Test cases for models"""
    
    def setUp(self):
        """Set up test data"""
        pass
    
    def get_valid_model_data(self, model_name):
        """Get valid test data for any model"""
        # TODO: Implement model-specific valid data
        return {{}}
'''.format(app_name=self.app_name)
        
        # Add individual test methods
        for test_case in model_tests:
            test_method = get_test_template(test_case)
            test_content += test_method + '\n'
        
        # Write model tests file
        with open(self.test_dir / 'test_models.py', 'w') as f:
            f.write(test_content)
        
        print(f"✅ Generated model tests: {len(model_tests)} test cases")
    
    def generate_serializer_tests(self):
        """Generate serializer test file"""
        serializer_tests = self.test_matrix.get('serializer_tests', [])
        
        if not serializer_tests:
            return
        
        test_content = '''"""
Serializer tests for {app_name}
Auto-generated from DD requirements
"""

from django.test import TestCase
from rest_framework.test import APITestCase
from django.contrib.auth.models import User
from apps.{app_name}.models import *
from apps.{app_name}.serializers import *


class SerializerTests(TestCase):
    """Test cases for serializers"""
    
    def setUp(self):
        """Set up test data"""
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
    
    def create_test_instance(self):
        """Create test model instance"""
        # TODO: Implement model instance creation
        pass
    
    def get_valid_serializer_data(self):
        """Get valid serializer data"""
        # TODO: Implement valid serializer data
        return {{}}
'''.format(app_name=self.app_name)
        
        # Add individual test methods
        for test_case in serializer_tests:
            test_method = get_test_template(test_case)
            test_content += test_method + '\n'
        
        # Write serializer tests file
        with open(self.test_dir / 'test_serializers.py', 'w') as f:
            f.write(test_content)
        
        print(f"✅ Generated serializer tests: {len(serializer_tests)} test cases")
    
    def generate_view_tests(self):
        """Generate view test file"""
        view_tests = self.test_matrix.get('view_tests', [])
        
        if not view_tests:
            return
        
        test_content = '''"""
View tests for {app_name}
Auto-generated from DD requirements
"""

from django.test import TestCase
from rest_framework.test import APITestCase, APIClient
from django.contrib.auth.models import User
from django.urls import reverse
from apps.{app_name}.models import *


class ViewTests(APITestCase):
    """Test cases for views"""
    
    def setUp(self):
        """Set up test data"""
        self.client = APIClient()
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
    
    def authenticate_user(self):
        """Authenticate test user"""
        self.client.force_authenticate(user=self.user)
    
    def create_user_without_permission(self):
        """Create user without specific permissions"""
        return User.objects.create_user(
            username='noperm',
            email='noperm@example.com',
            password='testpass123'
        )
'''.format(app_name=self.app_name)
        
        # Add individual test methods
        for test_case in view_tests:
            test_method = get_test_template(test_case)
            test_content += test_method + '\n'
        
        # Write view tests file
        with open(self.test_dir / 'test_views.py', 'w') as f:
            f.write(test_content)
        
        print(f"✅ Generated view tests: {len(view_tests)} test cases")
    
    def generate_api_tests(self):
        """Generate API integration test file"""
        api_tests = self.test_matrix.get('api_tests', [])
        
        if not api_tests:
            return
        
        test_content = '''"""
API integration tests for {app_name}
Auto-generated from DD requirements
"""

from django.test import TestCase
from rest_framework.test import APITestCase, APIClient
from django.contrib.auth.models import User
from django.urls import reverse
from apps.{app_name}.models import *
import json


class APIIntegrationTests(APITestCase):
    """Test cases for API integration"""
    
    def setUp(self):
        """Set up test data"""
        self.client = APIClient()
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
        self.client.force_authenticate(user=self.user)
    
    def test_crud_workflow(self):
        """Test complete CRUD workflow"""
        # TODO: Implement CRUD workflow test based on DD requirements
        pass
'''.format(app_name=self.app_name)
        
        # Add individual test methods
        for test_case in api_tests:
            test_method = get_test_template(test_case)
            test_content += test_method + '\n'
        
        # Write API tests file
        with open(self.test_dir / 'test_api.py', 'w') as f:
            f.write(test_content)
        
        print(f"✅ Generated API tests: {len(api_tests)} test cases")
    
    def generate_business_logic_tests(self):
        """Generate business logic test file"""
        business_tests = self.test_matrix.get('business_logic_tests', [])
        
        if not business_tests:
            return
        
        test_content = '''"""
Business logic tests for {app_name}
Auto-generated from DD requirements
"""

from django.test import TestCase
from django.contrib.auth.models import User
from apps.{app_name}.models import *


class BusinessLogicTests(TestCase):
    """Test cases for business logic"""
    
    def setUp(self):
        """Set up test data"""
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass123'
        )
'''.format(app_name=self.app_name)
        
        # Add individual test methods
        for test_case in business_tests:
            test_method = get_test_template(test_case)
            test_content += test_method + '\n'
        
        # Write business logic tests file
        with open(self.test_dir / 'test_business_logic.py', 'w') as f:
            f.write(test_content)
        
        print(f"✅ Generated business logic tests: {len(business_tests)} test cases")
    
    def generate_all_test_files(self):
        """Generate all test files"""
        print(f"Generating test files for {self.app_name}...")
        
        self.generate_model_tests()
        self.generate_serializer_tests()
        self.generate_view_tests()
        self.generate_api_tests()
        self.generate_business_logic_tests()
        
        # Generate test summary
        total_tests = sum(len(tests) for tests in self.test_matrix.values())
        
        summary = {
            'app_name': self.app_name,
            'total_test_cases': total_tests,
            'test_files_generated': [
                'test_models.py',
                'test_serializers.py', 
                'test_views.py',
                'test_api.py',
                'test_business_logic.py'
            ],
            'test_breakdown': {
                'model_tests': len(self.test_matrix.get('model_tests', [])),
                'serializer_tests': len(self.test_matrix.get('serializer_tests', [])),
                'view_tests': len(self.test_matrix.get('view_tests', [])),
                'api_tests': len(self.test_matrix.get('api_tests', [])),
                'business_logic_tests': len(self.test_matrix.get('business_logic_tests', []))
            }
        }
        
        # Save test generation summary
        with open('test_generation/generated_tests_summary.json', 'w') as f:
            json.dump(summary, f, indent=2)
        
        print(f"✅ Test generation complete!")
        print(f"   Total test cases: {total_tests}")
        print(f"   Test files created in: tests/test_{self.app_name}/")
        
        return summary


def generate_test_files():
    """Main function to generate test files"""
    # Load test matrix
    with open('test_generation/analysis/test_matrix.json', 'r') as f:
        test_matrix = json.load(f)
    
    generator = TestFileGenerator('${input:app_name}', test_matrix)
    summary = generator.generate_all_test_files()
    
    return summary


if __name__ == '__main__':
    generate_test_files()
```

## Output Generation

**Create the standardized test generation output using the template structure:**

```python
# Generate test generation summary following template structure
import json
from datetime import datetime
from pathlib import Path

def generate_test_generation_output():
    """Generate standardized test generation output"""
    
    # Create output directory structure
    base_dir = Path('test_generation')
    base_dir.mkdir(exist_ok=True)
    
    # Create subdirectories following template
    for subdir in ['metadata', 'analysis', 'templates', 'generated_tests', 'fixtures', 'documentation']:
        (base_dir / subdir).mkdir(exist_ok=True)
    
    # Generate main test generation summary JSON
    test_generation_summary = {
        "metadata": {
            "app_name": "${input:app_name}",
            "dd_name": "${input:dd_name}",
            "generated_at": datetime.now().isoformat(),
            "generated_by": "prompt_06.1",
            "version": "1.0"
        },
        "test_summary": {
            "total_test_cases": 0,  # Will be calculated
            "test_categories": {
                "model_tests": 0,
                "serializer_tests": 0,
                "view_tests": 0,
                "api_tests": 0,
                "business_logic_tests": 0,
                "integration_tests": 0
            },
            "coverage_targets": {
                "overall_target": 90,
                "model_coverage": 95,
                "view_coverage": 90,
                "api_coverage": 85
            }
        },
        "test_matrix": {
            "model_tests": [],
            "serializer_tests": [],
            "view_tests": [],
            "api_tests": [],
            "business_logic_tests": [],
            "integration_tests": []
        },
        "test_files_generated": [
            {
                "file_name": "test_models.py",
                "file_path": "tests/test_${input:app_name}/test_models.py",
                "test_count": 0,
                "test_types": ["model_creation", "field_validation", "model_methods"]
            },
            {
                "file_name": "test_serializers.py", 
                "file_path": "tests/test_${input:app_name}/test_serializers.py",
                "test_count": 0,
                "test_types": ["serializer_output", "serializer_input", "serializer_validation"]
            },
            {
                "file_name": "test_views.py",
                "file_path": "tests/test_${input:app_name}/test_views.py", 
                "test_count": 0,
                "test_types": ["view_response", "view_authentication", "view_permission"]
            },
            {
                "file_name": "test_api.py",
                "file_path": "tests/test_${input:app_name}/test_api.py",
                "test_count": 0, 
                "test_types": ["api_integration", "crud_workflow"]
            },
            {
                "file_name": "test_business_logic.py",
                "file_path": "tests/test_${input:app_name}/test_business_logic.py",
                "test_count": 0,
                "test_types": ["business_logic"]
            },
            {
                "file_name": "test_integration.py",
                "file_path": "tests/test_${input:app_name}/test_integration.py", 
                "test_count": 0,
                "test_types": ["integration", "end_to_end"]
            }
        ],
        "test_scenarios": {
            "positive_scenarios": [],
            "negative_scenarios": [], 
            "edge_cases": [],
            "performance_tests": []
        },
        "next_steps": [
            "Run prompt 06.2 to execute tests",
            "Review generated test files",
            "Customize test data if needed"
        ]
    }
    
    # Save main test generation summary
    with open(base_dir / 'metadata' / 'test_generation_summary.json', 'w') as f:
        json.dump(test_generation_summary, f, indent=2)
    
    # Generate supporting documentation
    generate_test_documentation(base_dir)
    
    print(f"✅ Test generation output created in {base_dir}/")
    print(f"📄 Main file: {base_dir}/metadata/test_generation_summary.json")
    print(f"📚 Documentation: {base_dir}/documentation/")
    
    return test_generation_summary

def generate_test_documentation(base_dir):
    """Generate test documentation files"""
    
    # Generate test plan markdown
    test_plan_md = f"""
# Test Plan: ${{input:dd_name}}

## Overview
[Test plan overview and strategy]

## Test Coverage
[Coverage requirements and targets]

## Test Types
[Description of different test types generated]

## Test Execution
[Instructions for running tests]

## Test Data
[Description of test data and fixtures]
"""
    
    with open(base_dir / 'documentation' / 'test_plan.md', 'w') as f:
        f.write(test_plan_md)

# Execute test generation workflow
def execute_test_generation():
    """Execute complete test generation workflow"""
    print("=== EXECUTING UNIT TEST GENERATION ===")
    
    # Step 1: Generate test matrix 
    print("Step 1: Generating test matrix...")
    # Load implementation plan and generate test matrix
    
    # Step 2: Generate test files
    print("Step 2: Generating test files...")
    # Generate actual test files based on matrix
    
    # Step 3: Create standardized output
    print("Step 3: Creating standardized output...")
    summary = generate_test_generation_output()
    
    # Step 4: Create test configuration
    print("Step 4: Creating test configuration...")
    
    print("✅ Unit test generation complete!")
    print("📁 Test files created in: tests/test_${input:app_name}/")
    print("📊 Test summary: test_generation/metadata/test_generation_summary.json")
    print("")
    print("Next step: Run prompt 06.2 to execute tests and generate reports")
    
    return summary

# Execute the workflow
execute_test_generation()
```

## Template Validation

**Ensure output meets template requirements:**

✅ **Metadata Section**: Complete with app name, DD name, generation timestamp  
✅ **Folder Structure**: Follows standardized template with metadata/, analysis/, templates/, etc.  
✅ **JSON Schema**: Matches template structure for test generation  
✅ **Test Files**: All test categories covered with proper file structure  
✅ **Documentation**: Includes both JSON and markdown formats  
✅ **Test Matrix**: Comprehensive test coverage analysis  
✅ **Cross-Prompt Compatibility**: Output format compatible with prompt 06.2 input requirements

## Success Criteria

**Test generation is successful when:**

✅ **Test matrix is generated based on DD requirements**  
✅ **All test files are created with proper structure**  
✅ **Test cases cover models, serializers, views, and business logic**  
✅ **Tests follow Django/DRF best practices**  
✅ **Test templates are reusable and maintainable**  
✅ **Comprehensive test summary is generated**

---

**Note**: This prompt generates the unit test code structure. Use prompt 06.2 to execute the tests and generate reports.