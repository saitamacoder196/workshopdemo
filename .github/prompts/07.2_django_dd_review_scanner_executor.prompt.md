---
description: Execute automated code reviews and security scans based on checklists from prompt 07.1
---

# Django Design Detail (DD) Review Scanner & Executor

This prompt executes automated reviews and security scans based on the checklists created in prompt 07.1, generating detailed reports with findings, recommendations, and quality scores.

## Prerequisites

**Required Input:**
- 📋 **Review Checklists**: Output from `07.1_django_dd_review_checklist_creator.prompt.md`
- 📦 **Project Name**: `${input:project_name}`
- 🏷️ **App Name**: `${input:app_name}`
- 📂 **Code Base Path**: `${input:code_base_path}`
- 📄 **Checklist Path**: `review_checklists/`

## Review Execution Workflow

### Step 1: Setup Review Environment

**Prepare environment for automated reviews:**

```bash
echo "=== SETTING UP REVIEW EXECUTION ENVIRONMENT ==="

# Create review results directories
mkdir -p review_results/{quality,security,detailed,reports}

# Check if checklists exist
if [ ! -f "review_checklists/quality/quality_checklist.json" ]; then
    echo "❌ Quality checklist not found. Run prompt 07.1 first."
    exit 1
fi

if [ ! -f "review_checklists/security/security_checklist.json" ]; then
    echo "❌ Security checklist not found. Run prompt 07.1 first."
    exit 1
fi

echo "✅ Review checklists found"

# Install review tools
echo "Installing review tools..."
pip install bandit safety flake8 mypy pylint radon xenon 2>/dev/null || echo "Tools already installed"

echo "✅ Review environment ready"
```

### Step 2: Execute Quality Reviews

**Run automated quality reviews based on quality checklist:**

```python
# File: review_execution/quality_reviewer.py

"""
Automated quality review executor based on quality checklist
"""

import json
import subprocess
import ast
import re
from pathlib import Path
from typing import Dict, List, Any
from datetime import datetime

class QualityReviewer:
    """Execute automated quality reviews"""
    
    def __init__(self, app_name: str, checklist_path: str):
        self.app_name = app_name
        self.checklist_path = checklist_path
        
        # Load quality checklist
        with open(f"{checklist_path}/quality/quality_checklist.json", 'r') as f:
            self.quality_checklist = json.load(f)
        
        self.review_results = {
            'metadata': {
                'app_name': app_name,
                'review_start': datetime.now().isoformat(),
                'review_type': 'quality',
                'checklist_version': self.quality_checklist['metadata']['checklist_version']
            },
            'category_results': {},
            'overall_score': 0,
            'findings': [],
            'recommendations': []
        }
    
    def check_django_best_practices(self) -> Dict:
        """Check Django best practices"""
        print("Checking Django best practices...")
        
        category_results = {
            'category': 'Django Best Practices',
            'checks_passed': 0,
            'checks_failed': 0,
            'check_results': []
        }
        
        checks = self.quality_checklist['categories']['django_best_practices']['checks']
        
        for check in checks:
            check_result = self._execute_django_check(check)
            category_results['check_results'].append(check_result)
            
            if check_result['status'] == 'pass':
                category_results['checks_passed'] += 1
            else:
                category_results['checks_failed'] += 1
        
        return category_results
    
    def check_code_quality_standards(self) -> Dict:
        """Check code quality standards"""
        print("Checking code quality standards...")
        
        category_results = {
            'category': 'Code Quality Standards',
            'checks_passed': 0,
            'checks_failed': 0,
            'check_results': []
        }
        
        checks = self.quality_checklist['categories']['code_quality']['checks']
        
        for check in checks:
            check_result = self._execute_quality_check(check)
            category_results['check_results'].append(check_result)
            
            if check_result['status'] == 'pass':
                category_results['checks_passed'] += 1
            else:
                category_results['checks_failed'] += 1
        
        return category_results
    
    def check_performance_optimization(self) -> Dict:
        """Check performance optimization"""
        print("Checking performance optimization...")
        
        category_results = {
            'category': 'Performance Optimization',
            'checks_passed': 0,
            'checks_failed': 0,
            'check_results': []
        }
        
        checks = self.quality_checklist['categories']['performance']['checks']
        
        for check in checks:
            check_result = self._execute_performance_check(check)
            category_results['check_results'].append(check_result)
            
            if check_result['status'] == 'pass':
                category_results['checks_passed'] += 1
            else:
                category_results['checks_failed'] += 1
        
        return category_results
    
    def check_dd_requirements_compliance(self) -> Dict:
        """Check DD requirements compliance"""
        print("Checking DD requirements compliance...")
        
        category_results = {
            'category': 'DD Requirements Compliance',
            'checks_passed': 0,
            'checks_failed': 0,
            'check_results': []
        }
        
        checks = self.quality_checklist['categories']['dd_requirements']['checks']
        
        for check in checks:
            check_result = self._execute_dd_compliance_check(check)
            category_results['check_results'].append(check_result)
            
            if check_result['status'] == 'pass':
                category_results['checks_passed'] += 1
            else:
                category_results['checks_failed'] += 1
        
        return category_results
    
    def _execute_django_check(self, check: Dict) -> Dict:
        """Execute Django best practices check"""
        check_result = {
            'check_id': check['id'],
            'title': check['title'],
            'status': 'pass',
            'findings': [],
            'score': 100
        }
        
        if check['id'] == 'DBP001':  # Model Field Definitions
            findings = self._check_model_fields()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 10)
        
        elif check['id'] == 'DBP002':  # Model Meta Configuration
            findings = self._check_model_meta()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 15)
        
        elif check['id'] == 'DBP003':  # Serializer Implementation
            findings = self._check_serializers()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 10)
        
        elif check['id'] == 'DBP004':  # View Implementation
            findings = self._check_views()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 10)
        
        elif check['id'] == 'DBP005':  # URL Configuration
            findings = self._check_urls()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 15)
        
        elif check['id'] == 'DBP006':  # Settings Configuration
            findings = self._check_settings()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 20)
        
        return check_result
    
    def _execute_quality_check(self, check: Dict) -> Dict:
        """Execute code quality check"""
        check_result = {
            'check_id': check['id'],
            'title': check['title'],
            'status': 'pass',
            'findings': [],
            'score': 100
        }
        
        if check['id'] == 'CQS001':  # Code Documentation
            findings = self._check_documentation()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 5)
        
        elif check['id'] == 'CQS002':  # Code Style Compliance
            findings = self._check_code_style()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 2)
        
        elif check['id'] == 'CQS003':  # Error Handling
            findings = self._check_error_handling()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 10)
        
        elif check['id'] == 'CQS004':  # Code Complexity
            findings = self._check_code_complexity()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 10)
        
        elif check['id'] == 'CQS005':  # Test Coverage
            findings = self._check_test_coverage()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 15)
        
        return check_result
    
    def _execute_performance_check(self, check: Dict) -> Dict:
        """Execute performance check"""
        check_result = {
            'check_id': check['id'],
            'title': check['title'],
            'status': 'pass',
            'findings': [],
            'score': 100
        }
        
        if check['id'] == 'PER001':  # Database Query Optimization
            findings = self._check_query_optimization()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 15)
        
        elif check['id'] == 'PER002':  # API Response Time
            findings = self._check_api_response()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 10)
        
        elif check['id'] == 'PER003':  # Memory Usage
            findings = self._check_memory_usage()
            if findings:
                check_result['status'] = 'fail'
                check_result['findings'] = findings
                check_result['score'] = max(0, 100 - len(findings) * 10)
        
        return check_result
    
    def _execute_dd_compliance_check(self, check: Dict) -> Dict:
        """Execute DD compliance check"""
        check_result = {
            'check_id': check['id'],
            'title': check['title'],
            'status': 'pass',
            'findings': [],
            'score': 100
        }
        
        # DD compliance checks are mostly manual verification
        # This would check for basic implementation presence
        dd_reference = check.get('dd_reference', {})
        
        if 'path' in dd_reference:  # API endpoint check
            findings = self._check_api_endpoint_implementation(dd_reference)
        elif 'name' in dd_reference and 'fields' in dd_reference:  # Model check
            findings = self._check_model_implementation(dd_reference)
        else:  # Business rule check
            findings = self._check_business_rule_implementation(dd_reference)
        
        if findings:
            check_result['status'] = 'fail'
            check_result['findings'] = findings
            check_result['score'] = max(0, 100 - len(findings) * 20)
        
        return check_result
    
    def _check_model_fields(self) -> List[str]:
        """Check model field definitions"""
        findings = []
        models_file = Path(f'apps/{self.app_name}/models.py')
        
        if not models_file.exists():
            findings.append("models.py file not found")
            return findings
        
        with open(models_file, 'r') as f:
            content = f.read()
        
        # Check for common field issues
        lines = content.split('\n')
        for i, line in enumerate(lines, 1):
            if 'CharField(' in line and 'max_length=' not in line:
                findings.append(f"Line {i}: CharField without max_length")
            
            if 'ForeignKey(' in line and 'on_delete=' not in line:
                findings.append(f"Line {i}: ForeignKey without on_delete")
        
        return findings
    
    def _check_model_meta(self) -> List[str]:
        """Check model Meta configuration"""
        findings = []
        models_file = Path(f'apps/{self.app_name}/models.py')
        
        if not models_file.exists():
            return findings
        
        with open(models_file, 'r') as f:
            content = f.read()
        
        # Look for models without Meta class
        if 'class Meta:' not in content and 'class ' in content:
            findings.append("Model classes found without Meta configuration")
        
        return findings
    
    def _check_serializers(self) -> List[str]:
        """Check serializer implementation"""
        findings = []
        serializers_file = Path(f'apps/{self.app_name}/serializers.py')
        
        if not serializers_file.exists():
            findings.append("serializers.py file not found")
            return findings
        
        with open(serializers_file, 'r') as f:
            content = f.read()
        
        # Check for basic serializer patterns
        if 'ModelSerializer' not in content:
            findings.append("No ModelSerializer classes found")
        
        if 'validate(' not in content and 'Serializer' in content:
            findings.append("Serializers lack custom validation methods")
        
        return findings
    
    def _check_views(self) -> List[str]:
        """Check view implementation"""
        findings = []
        views_file = Path(f'apps/{self.app_name}/views.py')
        
        if not views_file.exists():
            findings.append("views.py file not found")
            return findings
        
        with open(views_file, 'r') as f:
            content = f.read()
        
        # Check for basic view patterns
        if 'permission_classes' not in content and 'ViewSet' in content:
            findings.append("ViewSets lack permission_classes")
        
        if 'get_queryset' not in content and 'ViewSet' in content:
            findings.append("ViewSets lack optimized get_queryset method")
        
        return findings
    
    def _check_urls(self) -> List[str]:
        """Check URL configuration"""
        findings = []
        urls_file = Path(f'apps/{self.app_name}/urls.py')
        
        if not urls_file.exists():
            findings.append("urls.py file not found")
            return findings
        
        with open(urls_file, 'r') as f:
            content = f.read()
        
        # Check for basic URL patterns
        if 'router' not in content.lower() and 'viewset' in content.lower():
            findings.append("ViewSets not registered with router")
        
        return findings
    
    def _check_settings(self) -> List[str]:
        """Check settings configuration"""
        findings = []
        
        settings_files = [
            'config/settings/base.py',
            'config/settings.py', 
            'settings.py'
        ]
        
        settings_content = ""
        for settings_file in settings_files:
            if Path(settings_file).exists():
                with open(settings_file, 'r') as f:
                    settings_content += f.read()
                break
        
        if not settings_content:
            findings.append("Django settings file not found")
            return findings
        
        # Check if app is in INSTALLED_APPS
        if f'apps.{self.app_name}' not in settings_content and f'{self.app_name}' not in settings_content:
            findings.append(f"App {self.app_name} not found in INSTALLED_APPS")
        
        return findings
    
    def _check_documentation(self) -> List[str]:
        """Check code documentation"""
        findings = []
        
        # Run docstring checker
        result = subprocess.run(
            ['python', '-m', 'pydocstyle', f'apps/{self.app_name}/'],
            capture_output=True,
            text=True
        )
        
        if result.stdout:
            doc_issues = result.stdout.split('\n')
            findings.extend([issue for issue in doc_issues if issue.strip()])
        
        return findings[:10]  # Limit findings
    
    def _check_code_style(self) -> List[str]:
        """Check code style compliance"""
        findings = []
        
        # Run flake8
        result = subprocess.run(
            ['flake8', f'apps/{self.app_name}/', '--max-line-length=88'],
            capture_output=True,
            text=True
        )
        
        if result.stdout:
            style_issues = result.stdout.split('\n')
            findings.extend([issue for issue in style_issues if issue.strip()])
        
        return findings[:15]  # Limit findings
    
    def _check_error_handling(self) -> List[str]:
        """Check error handling"""
        findings = []
        
        for py_file in Path(f'apps/{self.app_name}').glob('*.py'):
            with open(py_file, 'r') as f:
                content = f.read()
            
            # Basic error handling checks
            if 'try:' in content and 'except Exception:' in content:
                findings.append(f"{py_file.name}: Broad exception catching detected")
            
            if 'raise Exception(' in content:
                findings.append(f"{py_file.name}: Generic Exception raised")
        
        return findings
    
    def _check_code_complexity(self) -> List[str]:
        """Check code complexity"""
        findings = []
        
        # Run radon for complexity
        result = subprocess.run(
            ['radon', 'cc', f'apps/{self.app_name}/', '-s'],
            capture_output=True,
            text=True
        )
        
        if result.stdout:
            complexity_lines = result.stdout.split('\n')
            for line in complexity_lines:
                if 'C' in line or 'D' in line or 'E' in line or 'F' in line:
                    findings.append(line.strip())
        
        return findings[:10]  # Limit findings
    
    def _check_test_coverage(self) -> List[str]:
        """Check test coverage"""
        findings = []
        
        # Check if test files exist
        test_dir = Path(f'tests/test_{self.app_name}')
        if not test_dir.exists():
            findings.append("Test directory not found")
            return findings
        
        test_files = list(test_dir.glob('*.py'))
        if len(test_files) < 3:
            findings.append("Insufficient test files (should have at least 3)")
        
        return findings
    
    def _check_query_optimization(self) -> List[str]:
        """Check database query optimization"""
        findings = []
        
        views_file = Path(f'apps/{self.app_name}/views.py')
        if views_file.exists():
            with open(views_file, 'r') as f:
                content = f.read()
            
            # Check for N+1 query issues
            if '.all()' in content and 'select_related' not in content:
                findings.append("Potential N+1 query: .all() without select_related")
            
            if 'filter(' in content and 'prefetch_related' not in content:
                findings.append("Consider using prefetch_related for related fields")
        
        return findings
    
    def _check_api_response(self) -> List[str]:
        """Check API response optimization"""
        findings = []
        
        views_file = Path(f'apps/{self.app_name}/views.py')
        if views_file.exists():
            with open(views_file, 'r') as f:
                content = f.read()
            
            # Check for pagination
            if 'ViewSet' in content and 'pagination_class' not in content:
                findings.append("ViewSets should implement pagination")
        
        return findings
    
    def _check_memory_usage(self) -> List[str]:
        """Check memory usage optimization"""
        findings = []
        
        # Basic memory usage checks
        for py_file in Path(f'apps/{self.app_name}').glob('*.py'):
            with open(py_file, 'r') as f:
                content = f.read()
            
            if '.all()' in content and 'iterator()' not in content:
                findings.append(f"{py_file.name}: Consider using iterator() for large querysets")
        
        return findings
    
    def _check_api_endpoint_implementation(self, endpoint: Dict) -> List[str]:
        """Check if API endpoint is implemented"""
        findings = []
        
        path = endpoint.get('path', '')
        method = endpoint.get('method', 'GET')
        
        # Check if endpoint exists in URLs
        urls_file = Path(f'apps/{self.app_name}/urls.py')
        if urls_file.exists():
            with open(urls_file, 'r') as f:
                content = f.read()
            
            # Simple check for path pattern
            path_pattern = path.replace('/', '').replace('{', '').replace('}', '')
            if path_pattern not in content:
                findings.append(f"API endpoint {path} may not be implemented")
        else:
            findings.append("urls.py file not found")
        
        return findings
    
    def _check_model_implementation(self, model: Dict) -> List[str]:
        """Check if model is implemented"""
        findings = []
        
        model_name = model.get('name', '')
        
        models_file = Path(f'apps/{self.app_name}/models.py')
        if models_file.exists():
            with open(models_file, 'r') as f:
                content = f.read()
            
            if f'class {model_name}' not in content:
                findings.append(f"Model {model_name} not found")
        else:
            findings.append("models.py file not found")
        
        return findings
    
    def _check_business_rule_implementation(self, rule: Dict) -> List[str]:
        """Check if business rule is implemented"""
        findings = []
        
        # Business rules are typically implemented across multiple files
        # This is a simplified check
        rule_description = rule.get('description', '').lower()
        
        files_to_check = [
            f'apps/{self.app_name}/models.py',
            f'apps/{self.app_name}/serializers.py',
            f'apps/{self.app_name}/views.py'
        ]
        
        rule_found = False
        for file_path in files_to_check:
            if Path(file_path).exists():
                with open(file_path, 'r') as f:
                    content = f.read().lower()
                
                # Simple keyword search
                if any(word in content for word in rule_description.split()[:3] if len(word) > 3):
                    rule_found = True
                    break
        
        if not rule_found:
            findings.append(f"Business rule implementation not clearly found: {rule.get('name', 'Unknown')}")
        
        return findings
    
    def execute_quality_review(self) -> Dict:
        """Execute complete quality review"""
        print("=== EXECUTING QUALITY REVIEW ===")
        
        # Execute all category checks
        self.review_results['category_results']['django_best_practices'] = self.check_django_best_practices()
        self.review_results['category_results']['code_quality'] = self.check_code_quality_standards()
        self.review_results['category_results']['performance'] = self.check_performance_optimization()
        self.review_results['category_results']['dd_compliance'] = self.check_dd_requirements_compliance()
        
        # Calculate overall score
        total_score = 0
        total_checks = 0
        
        for category_result in self.review_results['category_results'].values():
            for check_result in category_result['check_results']:
                total_score += check_result['score']
                total_checks += 1
        
        self.review_results['overall_score'] = total_score / total_checks if total_checks > 0 else 0
        
        # Collect all findings
        for category_result in self.review_results['category_results'].values():
            for check_result in category_result['check_results']:
                if check_result['status'] == 'fail':
                    self.review_results['findings'].extend(check_result['findings'])
        
        # Generate recommendations
        self.review_results['recommendations'] = self._generate_quality_recommendations()
        
        self.review_results['metadata']['review_end'] = datetime.now().isoformat()
        
        return self.review_results
    
    def _generate_quality_recommendations(self) -> List[str]:
        """Generate quality improvement recommendations"""
        recommendations = []
        
        overall_score = self.review_results['overall_score']
        
        if overall_score < 70:
            recommendations.append("Code quality is below acceptable standards. Focus on fixing critical issues.")
        elif overall_score < 85:
            recommendations.append("Code quality is good but has room for improvement.")
        else:
            recommendations.append("Excellent code quality! Minor improvements possible.")
        
        # Category-specific recommendations
        for category_name, category_result in self.review_results['category_results'].items():
            if category_result['checks_failed'] > 0:
                if category_name == 'django_best_practices':
                    recommendations.append("Review Django best practices documentation and apply fixes.")
                elif category_name == 'code_quality':
                    recommendations.append("Improve code documentation and style compliance.")
                elif category_name == 'performance':
                    recommendations.append("Optimize database queries and API response times.")
                elif category_name == 'dd_compliance':
                    recommendations.append("Ensure all DD requirements are properly implemented.")
        
        return recommendations


def execute_quality_review():
    """Main function to execute quality review"""
    reviewer = QualityReviewer('${input:app_name}', 'review_checklists')
    results = reviewer.execute_quality_review()
    
    # Save results
    with open('review_results/quality/quality_review_results.json', 'w') as f:
        json.dump(results, f, indent=2)
    
    print(f"✅ Quality review complete. Score: {results['overall_score']:.1f}/100")
    return results


if __name__ == '__main__':
    execute_quality_review()
```

### Step 3: Execute Security Scans

**Run automated security scans based on security checklist:**

```python
# File: review_execution/security_scanner.py

"""
Automated security scanner based on security checklist
"""

import json
import subprocess
import re
from pathlib import Path
from typing import Dict, List
from datetime import datetime

class SecurityScanner:
    """Execute automated security scans"""
    
    def __init__(self, app_name: str, checklist_path: str):
        self.app_name = app_name
        self.checklist_path = checklist_path
        
        # Load security checklist
        with open(f"{checklist_path}/security/security_checklist.json", 'r') as f:
            self.security_checklist = json.load(f)
        
        self.scan_results = {
            'metadata': {
                'app_name': app_name,
                'scan_start': datetime.now().isoformat(),
                'scan_type': 'security',
                'checklist_version': self.security_checklist['metadata']['checklist_version']
            },
            'category_results': {},
            'overall_risk_level': 'low',
            'vulnerabilities': [],
            'recommendations': []
        }
    
    def scan_owasp_vulnerabilities(self) -> Dict:
        """Scan for OWASP Top 10 vulnerabilities"""
        print("Scanning for OWASP Top 10 vulnerabilities...")
        
        category_results = {
            'category': 'OWASP Top 10 Security Risks',
            'vulnerabilities_found': 0,
            'checks_passed': 0,
            'scan_results': []
        }
        
        checks = self.security_checklist['categories']['owasp_top10']['checks']
        
        for check in checks:
            scan_result = self._execute_owasp_check(check)
            category_results['scan_results'].append(scan_result)
            
            if scan_result['vulnerabilities']:
                category_results['vulnerabilities_found'] += len(scan_result['vulnerabilities'])
            else:
                category_results['checks_passed'] += 1
        
        return category_results
    
    def scan_django_security(self) -> Dict:
        """Scan Django-specific security issues"""
        print("Scanning Django security configurations...")
        
        category_results = {
            'category': 'Django Security Best Practices',
            'vulnerabilities_found': 0,
            'checks_passed': 0,
            'scan_results': []
        }
        
        checks = self.security_checklist['categories']['django_security']['checks']
        
        for check in checks:
            scan_result = self._execute_django_security_check(check)
            category_results['scan_results'].append(scan_result)
            
            if scan_result['vulnerabilities']:
                category_results['vulnerabilities_found'] += len(scan_result['vulnerabilities'])
            else:
                category_results['checks_passed'] += 1
        
        return category_results
    
    def scan_api_security(self) -> Dict:
        """Scan API-specific security issues"""
        print("Scanning API security...")
        
        category_results = {
            'category': 'API Security',
            'vulnerabilities_found': 0,
            'checks_passed': 0,
            'scan_results': []
        }
        
        checks = self.security_checklist['categories']['api_security']['checks']
        
        for check in checks:
            scan_result = self._execute_api_security_check(check)
            category_results['scan_results'].append(scan_result)
            
            if scan_result['vulnerabilities']:
                category_results['vulnerabilities_found'] += len(scan_result['vulnerabilities'])
            else:
                category_results['checks_passed'] += 1
        
        return category_results
    
    def run_bandit_scan(self) -> Dict:
        """Run Bandit security scanner"""
        print("Running Bandit security scanner...")
        
        result = subprocess.run(
            ['bandit', '-r', f'apps/{self.app_name}/', '-f', 'json'],
            capture_output=True,
            text=True
        )
        
        bandit_results = {
            'tool': 'bandit',
            'vulnerabilities': [],
            'summary': {}
        }
        
        if result.stdout:
            try:
                bandit_data = json.loads(result.stdout)
                bandit_results['vulnerabilities'] = bandit_data.get('results', [])
                bandit_results['summary'] = bandit_data.get('metrics', {})
            except json.JSONDecodeError:
                bandit_results['error'] = 'Failed to parse Bandit output'
        
        return bandit_results
    
    def run_safety_check(self) -> Dict:
        """Run Safety dependency checker"""
        print("Running Safety dependency checker...")
        
        result = subprocess.run(
            ['safety', 'check', '--json'],
            capture_output=True,
            text=True
        )
        
        safety_results = {
            'tool': 'safety',
            'vulnerabilities': [],
            'summary': {}
        }
        
        if result.stdout:
            try:
                safety_data = json.loads(result.stdout)
                safety_results['vulnerabilities'] = safety_data
                safety_results['summary'] = {'vulnerable_packages': len(safety_data)}
            except json.JSONDecodeError:
                safety_results['error'] = 'Failed to parse Safety output'
        
        return safety_results
    
    def _execute_owasp_check(self, check: Dict) -> Dict:
        """Execute OWASP security check"""
        scan_result = {
            'check_id': check['id'],
            'title': check['title'],
            'vulnerabilities': [],
            'risk_level': 'low'
        }
        
        if check['id'] == 'OWASP001':  # Broken Access Control
            vulnerabilities = self._check_access_control()
        elif check['id'] == 'OWASP002':  # Cryptographic Failures
            vulnerabilities = self._check_cryptographic_failures()
        elif check['id'] == 'OWASP003':  # Injection
            vulnerabilities = self._check_injection_vulnerabilities()
        elif check['id'] == 'OWASP005':  # Security Misconfiguration
            vulnerabilities = self._check_security_misconfiguration()
        elif check['id'] == 'OWASP007':  # Authentication Failures
            vulnerabilities = self._check_authentication_failures()
        else:
            vulnerabilities = []  # Other checks require manual review
        
        scan_result['vulnerabilities'] = vulnerabilities
        if vulnerabilities:
            scan_result['risk_level'] = check['severity']
        
        return scan_result
    
    def _execute_django_security_check(self, check: Dict) -> Dict:
        """Execute Django security check"""
        scan_result = {
            'check_id': check['id'],
            'title': check['title'],
            'vulnerabilities': [],
            'risk_level': 'low'
        }
        
        if check['id'] == 'DSP001':  # Django Security Settings
            vulnerabilities = self._check_django_settings()
        elif check['id'] == 'DSP002':  # CSRF Protection
            vulnerabilities = self._check_csrf_protection()
        elif check['id'] == 'DSP003':  # XSS Protection
            vulnerabilities = self._check_xss_protection()
        elif check['id'] == 'DSP004':  # Authentication and Authorization
            vulnerabilities = self._check_auth_implementation()
        elif check['id'] == 'DSP005':  # SQL Injection Protection
            vulnerabilities = self._check_sql_injection_protection()
        else:
            vulnerabilities = []
        
        scan_result['vulnerabilities'] = vulnerabilities
        if vulnerabilities:
            scan_result['risk_level'] = check['severity']
        
        return scan_result
    
    def _execute_api_security_check(self, check: Dict) -> Dict:
        """Execute API security check"""
        scan_result = {
            'check_id': check['id'],
            'title': check['title'],
            'vulnerabilities': [],
            'risk_level': 'low'
        }
        
        if check['id'] == 'API001':  # API Authentication
            vulnerabilities = self._check_api_authentication()
        elif check['id'] == 'API002':  # Input Validation
            vulnerabilities = self._check_api_input_validation()
        elif check['id'] == 'API003':  # Error Handling
            vulnerabilities = self._check_api_error_handling()
        elif check['id'] == 'API004':  # Data Exposure
            vulnerabilities = self._check_api_data_exposure()
        else:
            vulnerabilities = []
        
        scan_result['vulnerabilities'] = vulnerabilities
        if vulnerabilities:
            scan_result['risk_level'] = check['severity']
        
        return scan_result
    
    def _check_access_control(self) -> List[Dict]:
        """Check for access control issues"""
        vulnerabilities = []
        
        views_file = Path(f'apps/{self.app_name}/views.py')
        if views_file.exists():
            with open(views_file, 'r') as f:
                content = f.read()
            
            # Check for missing permission classes
            if 'ViewSet' in content and 'permission_classes' not in content:
                vulnerabilities.append({
                    'type': 'missing_permissions',
                    'description': 'ViewSets without permission_classes',
                    'file': str(views_file),
                    'severity': 'high'
                })
        
        return vulnerabilities
    
    def _check_cryptographic_failures(self) -> List[Dict]:
        """Check for cryptographic issues"""
        vulnerabilities = []
        
        # Check for hardcoded secrets
        for py_file in Path(f'apps/{self.app_name}').glob('*.py'):
            with open(py_file, 'r') as f:
                content = f.read()
            
            # Simple patterns for hardcoded secrets
            secret_patterns = [
                r'password\s*=\s*["\'][^"\']+["\']',
                r'secret\s*=\s*["\'][^"\']+["\']',
                r'key\s*=\s*["\'][^"\']+["\']'
            ]
            
            for pattern in secret_patterns:
                if re.search(pattern, content, re.IGNORECASE):
                    vulnerabilities.append({
                        'type': 'hardcoded_secret',
                        'description': 'Potential hardcoded secret found',
                        'file': str(py_file),
                        'severity': 'high'
                    })
                    break
        
        return vulnerabilities
    
    def _check_injection_vulnerabilities(self) -> List[Dict]:
        """Check for injection vulnerabilities"""
        vulnerabilities = []
        
        # Check for raw SQL usage
        for py_file in Path(f'apps/{self.app_name}').glob('*.py'):
            with open(py_file, 'r') as f:
                content = f.read()
            
            if 'cursor.execute(' in content and '%s' not in content:
                vulnerabilities.append({
                    'type': 'sql_injection_risk',
                    'description': 'Raw SQL without parameterization',
                    'file': str(py_file),
                    'severity': 'critical'
                })
        
        return vulnerabilities
    
    def _check_security_misconfiguration(self) -> List[Dict]:
        """Check for security misconfigurations"""
        vulnerabilities = []
        
        # Check Django settings
        settings_files = ['config/settings/base.py', 'config/settings.py', 'settings.py']
        
        for settings_file in settings_files:
            if Path(settings_file).exists():
                with open(settings_file, 'r') as f:
                    content = f.read()
                
                # Check for DEBUG = True
                if 'DEBUG = True' in content:
                    vulnerabilities.append({
                        'type': 'debug_enabled',
                        'description': 'DEBUG mode enabled',
                        'file': settings_file,
                        'severity': 'high'
                    })
                
                # Check for missing security headers
                if 'SECURE_SSL_REDIRECT' not in content:
                    vulnerabilities.append({
                        'type': 'missing_security_header',
                        'description': 'SECURE_SSL_REDIRECT not configured',
                        'file': settings_file,
                        'severity': 'medium'
                    })
                
                break
        
        return vulnerabilities
    
    def _check_authentication_failures(self) -> List[Dict]:
        """Check for authentication issues"""
        vulnerabilities = []
        
        views_file = Path(f'apps/{self.app_name}/views.py')
        if views_file.exists():
            with open(views_file, 'r') as f:
                content = f.read()
            
            # Check for missing authentication
            if 'ViewSet' in content and 'authentication_classes' not in content:
                vulnerabilities.append({
                    'type': 'missing_authentication',
                    'description': 'ViewSets without authentication_classes',
                    'file': str(views_file),
                    'severity': 'high'
                })
        
        return vulnerabilities
    
    def _check_django_settings(self) -> List[Dict]:
        """Check Django security settings"""
        vulnerabilities = []
        
        settings_files = ['config/settings/base.py', 'config/settings.py', 'settings.py']
        
        for settings_file in settings_files:
            if Path(settings_file).exists():
                with open(settings_file, 'r') as f:
                    content = f.read()
                
                # Check critical security settings
                security_checks = [
                    ('SECRET_KEY', 'Missing SECRET_KEY'),
                    ('ALLOWED_HOSTS', 'Missing ALLOWED_HOSTS'),
                    ('SESSION_COOKIE_SECURE', 'SESSION_COOKIE_SECURE not set'),
                    ('CSRF_COOKIE_SECURE', 'CSRF_COOKIE_SECURE not set')
                ]
                
                for setting, description in security_checks:
                    if setting not in content:
                        vulnerabilities.append({
                            'type': 'missing_security_setting',
                            'description': description,
                            'file': settings_file,
                            'severity': 'medium'
                        })
                
                break
        
        return vulnerabilities
    
    def _check_csrf_protection(self) -> List[Dict]:
        """Check CSRF protection"""
        vulnerabilities = []
        
        views_file = Path(f'apps/{self.app_name}/views.py')
        if views_file.exists():
            with open(views_file, 'r') as f:
                content = f.read()
            
            # Check for CSRF exemption
            if 'csrf_exempt' in content:
                vulnerabilities.append({
                    'type': 'csrf_disabled',
                    'description': 'CSRF protection disabled',
                    'file': str(views_file),
                    'severity': 'high'
                })
        
        return vulnerabilities
    
    def _check_xss_protection(self) -> List[Dict]:
        """Check XSS protection"""
        vulnerabilities = []
        
        # Check for mark_safe usage
        for py_file in Path(f'apps/{self.app_name}').glob('*.py'):
            with open(py_file, 'r') as f:
                content = f.read()
            
            if 'mark_safe(' in content:
                vulnerabilities.append({
                    'type': 'xss_risk',
                    'description': 'mark_safe usage detected - review for XSS',
                    'file': str(py_file),
                    'severity': 'medium'
                })
        
        return vulnerabilities
    
    def _check_auth_implementation(self) -> List[Dict]:
        """Check authentication implementation"""
        vulnerabilities = []
        
        # This would be a more complex check in practice
        settings_files = ['config/settings/base.py', 'config/settings.py', 'settings.py']
        
        for settings_file in settings_files:
            if Path(settings_file).exists():
                with open(settings_file, 'r') as f:
                    content = f.read()
                
                if 'AUTH_PASSWORD_VALIDATORS' not in content:
                    vulnerabilities.append({
                        'type': 'weak_password_policy',
                        'description': 'Password validators not configured',
                        'file': settings_file,
                        'severity': 'medium'
                    })
                
                break
        
        return vulnerabilities
    
    def _check_sql_injection_protection(self) -> List[Dict]:
        """Check SQL injection protection"""
        vulnerabilities = []
        
        # Already covered in injection check
        return vulnerabilities
    
    def _check_api_authentication(self) -> List[Dict]:
        """Check API authentication"""
        vulnerabilities = []
        
        views_file = Path(f'apps/{self.app_name}/views.py')
        if views_file.exists():
            with open(views_file, 'r') as f:
                content = f.read()
            
            # Check for unauthenticated endpoints
            if 'AllowAny' in content:
                vulnerabilities.append({
                    'type': 'open_endpoint',
                    'description': 'Endpoints with AllowAny permission',
                    'file': str(views_file),
                    'severity': 'medium'
                })
        
        return vulnerabilities
    
    def _check_api_input_validation(self) -> List[Dict]:
        """Check API input validation"""
        vulnerabilities = []
        
        serializers_file = Path(f'apps/{self.app_name}/serializers.py')
        if serializers_file.exists():
            with open(serializers_file, 'r') as f:
                content = f.read()
            
            # Check for missing validation
            if 'Serializer' in content and 'validate(' not in content:
                vulnerabilities.append({
                    'type': 'insufficient_validation',
                    'description': 'Serializers lack custom validation',
                    'file': str(serializers_file),
                    'severity': 'medium'
                })
        
        return vulnerabilities
    
    def _check_api_error_handling(self) -> List[Dict]:
        """Check API error handling"""
        vulnerabilities = []
        
        views_file = Path(f'apps/{self.app_name}/views.py')
        if views_file.exists():
            with open(views_file, 'r') as f:
                content = f.read()
            
            # Check for exception handling
            if 'try:' not in content and 'ViewSet' in content:
                vulnerabilities.append({
                    'type': 'poor_error_handling',
                    'description': 'No exception handling in views',
                    'file': str(views_file),
                    'severity': 'low'
                })
        
        return vulnerabilities
    
    def _check_api_data_exposure(self) -> List[Dict]:
        """Check API data exposure"""
        vulnerabilities = []
        
        serializers_file = Path(f'apps/{self.app_name}/serializers.py')
        if serializers_file.exists():
            with open(serializers_file, 'r') as f:
                content = f.read()
            
            # Check for password fields in serializers
            if 'password' in content.lower() and 'write_only' not in content:
                vulnerabilities.append({
                    'type': 'sensitive_data_exposure',
                    'description': 'Password fields may be exposed',
                    'file': str(serializers_file),
                    'severity': 'high'
                })
        
        return vulnerabilities
    
    def execute_security_scan(self) -> Dict:
        """Execute complete security scan"""
        print("=== EXECUTING SECURITY SCAN ===")
        
        # Execute category scans
        self.scan_results['category_results']['owasp_top10'] = self.scan_owasp_vulnerabilities()
        self.scan_results['category_results']['django_security'] = self.scan_django_security()
        self.scan_results['category_results']['api_security'] = self.scan_api_security()
        
        # Run external tools
        self.scan_results['tool_results'] = {
            'bandit': self.run_bandit_scan(),
            'safety': self.run_safety_check()
        }
        
        # Collect all vulnerabilities
        all_vulnerabilities = []
        for category_result in self.scan_results['category_results'].values():
            for scan_result in category_result['scan_results']:
                all_vulnerabilities.extend(scan_result['vulnerabilities'])
        
        # Add tool vulnerabilities
        if self.scan_results['tool_results']['bandit']['vulnerabilities']:
            all_vulnerabilities.extend(self.scan_results['tool_results']['bandit']['vulnerabilities'])
        
        if self.scan_results['tool_results']['safety']['vulnerabilities']:
            all_vulnerabilities.extend(self.scan_results['tool_results']['safety']['vulnerabilities'])
        
        self.scan_results['vulnerabilities'] = all_vulnerabilities
        
        # Determine overall risk level
        self.scan_results['overall_risk_level'] = self._calculate_risk_level(all_vulnerabilities)
        
        # Generate recommendations
        self.scan_results['recommendations'] = self._generate_security_recommendations()
        
        self.scan_results['metadata']['scan_end'] = datetime.now().isoformat()
        
        return self.scan_results
    
    def _calculate_risk_level(self, vulnerabilities: List[Dict]) -> str:
        """Calculate overall risk level"""
        if not vulnerabilities:
            return 'low'
        
        critical_count = sum(1 for v in vulnerabilities if v.get('severity') == 'critical')
        high_count = sum(1 for v in vulnerabilities if v.get('severity') == 'high')
        
        if critical_count > 0:
            return 'critical'
        elif high_count > 2:
            return 'high'
        elif high_count > 0:
            return 'medium'
        else:
            return 'low'
    
    def _generate_security_recommendations(self) -> List[str]:
        """Generate security recommendations"""
        recommendations = []
        
        risk_level = self.scan_results['overall_risk_level']
        
        if risk_level == 'critical':
            recommendations.append("CRITICAL: Address critical vulnerabilities immediately before deployment.")
        elif risk_level == 'high':
            recommendations.append("HIGH: Multiple high-severity issues found. Priority fixes required.")
        elif risk_level == 'medium':
            recommendations.append("MEDIUM: Some security issues found. Review and fix before production.")
        else:
            recommendations.append("LOW: Good security posture. Minor improvements possible.")
        
        # Specific recommendations based on vulnerabilities
        vulnerability_types = set(v.get('type', '') for v in self.scan_results['vulnerabilities'])
        
        if 'hardcoded_secret' in vulnerability_types:
            recommendations.append("Remove hardcoded secrets and use environment variables.")
        
        if 'missing_permissions' in vulnerability_types:
            recommendations.append("Add proper permission classes to all ViewSets.")
        
        if 'sql_injection_risk' in vulnerability_types:
            recommendations.append("Use parameterized queries or Django ORM for database operations.")
        
        if 'debug_enabled' in vulnerability_types:
            recommendations.append("Disable DEBUG mode in production settings.")
        
        return recommendations


def execute_security_scan():
    """Main function to execute security scan"""
    scanner = SecurityScanner('${input:app_name}', 'review_checklists')
    results = scanner.execute_security_scan()
    
    # Save results
    with open('review_results/security/security_scan_results.json', 'w') as f:
        json.dump(results, f, indent=2)
    
    print(f"✅ Security scan complete. Risk level: {results['overall_risk_level'].upper()}")
    return results


if __name__ == '__main__':
    execute_security_scan()
```

### Step 4: Generate Comprehensive Review Reports

**Create detailed reports combining all review results:**

```python
# File: review_execution/review_reporter.py

"""
Generate comprehensive review reports combining quality and security results
"""

import json
from datetime import datetime
from pathlib import Path
from typing import Dict, List

class ComprehensiveReviewReporter:
    """Generate comprehensive review reports"""
    
    def __init__(self, app_name: str):
        self.app_name = app_name
        
        # Load review results
        self.quality_results = self._load_quality_results()
        self.security_results = self._load_security_results()
    
    def _load_quality_results(self) -> Dict:
        """Load quality review results"""
        try:
            with open('review_results/quality/quality_review_results.json', 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
    
    def _load_security_results(self) -> Dict:
        """Load security scan results"""
        try:
            with open('review_results/security/security_scan_results.json', 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {}
    
    def generate_executive_summary(self) -> str:
        """Generate executive summary report"""
        
        quality_score = self.quality_results.get('overall_score', 0)
        security_risk = self.security_results.get('overall_risk_level', 'unknown')
        
        # Calculate combined score
        combined_score = self._calculate_combined_score()
        
        summary = f"""
=== COMPREHENSIVE CODE REVIEW SUMMARY ===

App: {self.app_name}
Review Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

OVERALL ASSESSMENT:
📊 Combined Score: {combined_score:.1f}/100
📈 Quality Score: {quality_score:.1f}/100
🔒 Security Risk Level: {security_risk.upper()}

QUALITY REVIEW:
✅ Checks Passed: {self._count_quality_passes()}
❌ Checks Failed: {self._count_quality_failures()}
📄 Findings: {len(self.quality_results.get('findings', []))}

SECURITY SCAN:
🛡️ Vulnerabilities Found: {len(self.security_results.get('vulnerabilities', []))}
⚠️ Risk Level: {security_risk.upper()}
🔍 Tools Used: Bandit, Safety, Custom Checks

RECOMMENDATIONS:
"""
        
        # Add top recommendations
        quality_recs = self.quality_results.get('recommendations', [])
        security_recs = self.security_results.get('recommendations', [])
        
        all_recs = quality_recs + security_recs
        for i, rec in enumerate(all_recs[:5], 1):
            summary += f"{i}. {rec}\n"
        
        summary += f"""
NEXT STEPS:
1. Address {security_risk} risk security issues first
2. Fix quality issues with score impact
3. Re-run review after fixes
4. Proceed to deployment preparation
"""
        
        return summary
    
    def generate_detailed_html_report(self) -> str:
        """Generate detailed HTML report"""
        
        combined_score = self._calculate_combined_score()
        quality_score = self.quality_results.get('overall_score', 0)
        security_risk = self.security_results.get('overall_risk_level', 'unknown')
        
        html_report = f"""
<!DOCTYPE html>
<html>
<head>
    <title>Comprehensive Code Review Report - {self.app_name}</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .header {{ background: #f0f0f0; padding: 20px; margin-bottom: 20px; border-radius: 5px; }}
        .summary {{ display: flex; gap: 20px; margin-bottom: 30px; }}
        .metric-box {{ padding: 15px; border: 1px solid #ddd; border-radius: 5px; text-align: center; flex: 1; }}
        .excellent {{ background: #d4edda; border-color: #c3e6cb; }}
        .good {{ background: #fff3cd; border-color: #ffeaa7; }}
        .warning {{ background: #f8d7da; border-color: #f5c6cb; }}
        .critical {{ background: #f8d7da; border-color: #dc3545; }}
        .section {{ margin: 30px 0; }}
        .vulnerability {{ margin: 10px 0; padding: 10px; border-left: 4px solid #dc3545; background: #f8f9fa; }}
        .finding {{ margin: 10px 0; padding: 10px; border-left: 4px solid #ffc107; background: #f8f9fa; }}
        table {{ width: 100%; border-collapse: collapse; margin: 20px 0; }}
        th, td {{ padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }}
        th {{ background-color: #f5f5f5; }}
        .recommendations {{ background: #e3f2fd; padding: 20px; border-radius: 5px; }}
    </style>
</head>
<body>
    <div class="header">
        <h1>Comprehensive Code Review Report</h1>
        <h2>{self.app_name}</h2>
        <p><strong>Generated:</strong> {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
    </div>
    
    <div class="summary">
        <div class="metric-box {'excellent' if combined_score >= 90 else 'good' if combined_score >= 80 else 'warning' if combined_score >= 70 else 'critical'}">
            <h3>{combined_score:.1f}/100</h3>
            <p>Overall Score</p>
        </div>
        <div class="metric-box {'excellent' if quality_score >= 90 else 'good' if quality_score >= 80 else 'warning' if quality_score >= 70 else 'critical'}">
            <h3>{quality_score:.1f}/100</h3>
            <p>Quality Score</p>
        </div>
        <div class="metric-box {'excellent' if security_risk == 'low' else 'good' if security_risk == 'medium' else 'warning' if security_risk == 'high' else 'critical'}">
            <h3>{security_risk.upper()}</h3>
            <p>Security Risk</p>
        </div>
        <div class="metric-box">
            <h3>{len(self.security_results.get('vulnerabilities', []))}</h3>
            <p>Vulnerabilities</p>
        </div>
    </div>
"""
        
        # Quality Review Section
        html_report += self._generate_quality_section_html()
        
        # Security Review Section
        html_report += self._generate_security_section_html()
        
        # Recommendations Section
        html_report += self._generate_recommendations_section_html()
        
        html_report += """
</body>
</html>
"""
        
        return html_report
    
    def _generate_quality_section_html(self) -> str:
        """Generate quality review section HTML"""
        
        section_html = """
    <div class="section">
        <h2>Quality Review Results</h2>
"""
        
        for category_name, category_result in self.quality_results.get('category_results', {}).items():
            passed = category_result.get('checks_passed', 0)
            failed = category_result.get('checks_failed', 0)
            total = passed + failed
            
            section_html += f"""
        <h3>{category_result.get('category', category_name)}</h3>
        <p>Checks Passed: {passed}/{total} ({passed/total*100:.1f}% if total > 0 else 0)</p>
"""
            
            # Show failed checks
            for check_result in category_result.get('check_results', []):
                if check_result['status'] == 'fail':
                    section_html += f"""
        <div class="finding">
            <strong>{check_result['check_id']}: {check_result['title']}</strong>
            <br>Score: {check_result['score']}/100
            <br>Issues: {len(check_result['findings'])}
        </div>
"""
        
        section_html += "    </div>\n"
        return section_html
    
    def _generate_security_section_html(self) -> str:
        """Generate security review section HTML"""
        
        section_html = """
    <div class="section">
        <h2>Security Scan Results</h2>
"""
        
        vulnerabilities = self.security_results.get('vulnerabilities', [])
        
        if vulnerabilities:
            section_html += f"        <p>Found {len(vulnerabilities)} security issues:</p>\n"
            
            for vuln in vulnerabilities[:10]:  # Show top 10
                severity = vuln.get('severity', 'unknown')
                section_html += f"""
        <div class="vulnerability">
            <strong>{vuln.get('type', 'Unknown')}</strong> ({severity.upper()})
            <br>{vuln.get('description', 'No description')}
            <br>File: {vuln.get('file', 'Unknown')}
        </div>
"""
        else:
            section_html += "        <p>✅ No security vulnerabilities found!</p>\n"
        
        section_html += "    </div>\n"
        return section_html
    
    def _generate_recommendations_section_html(self) -> str:
        """Generate recommendations section HTML"""
        
        quality_recs = self.quality_results.get('recommendations', [])
        security_recs = self.security_results.get('recommendations', [])
        
        section_html = """
    <div class="section">
        <h2>Recommendations</h2>
        <div class="recommendations">
            <h3>Quality Improvements</h3>
            <ul>
"""
        
        for rec in quality_recs:
            section_html += f"                <li>{rec}</li>\n"
        
        section_html += """
            </ul>
            <h3>Security Improvements</h3>
            <ul>
"""
        
        for rec in security_recs:
            section_html += f"                <li>{rec}</li>\n"
        
        section_html += """
            </ul>
        </div>
    </div>
"""
        
        return section_html
    
    def _calculate_combined_score(self) -> float:
        """Calculate combined quality and security score"""
        quality_score = self.quality_results.get('overall_score', 0)
        
        # Convert security risk to score
        security_risk = self.security_results.get('overall_risk_level', 'low')
        security_score_map = {
            'low': 95,
            'medium': 75,
            'high': 50,
            'critical': 25
        }
        security_score = security_score_map.get(security_risk, 50)
        
        # Weight: 60% quality, 40% security
        combined_score = (quality_score * 0.6) + (security_score * 0.4)
        
        return combined_score
    
    def _count_quality_passes(self) -> int:
        """Count total quality checks passed"""
        total = 0
        for category_result in self.quality_results.get('category_results', {}).values():
            total += category_result.get('checks_passed', 0)
        return total
    
    def _count_quality_failures(self) -> int:
        """Count total quality checks failed"""
        total = 0
        for category_result in self.quality_results.get('category_results', {}).values():
            total += category_result.get('checks_failed', 0)
        return total
    
    def generate_all_reports(self):
        """Generate all report formats"""
        print("Generating comprehensive review reports...")
        
        # Executive summary
        summary = self.generate_executive_summary()
        with open('review_results/reports/executive_summary.txt', 'w') as f:
            f.write(summary)
        
        # Detailed HTML report
        html_report = self.generate_detailed_html_report()
        with open('review_results/reports/detailed_review_report.html', 'w') as f:
            f.write(html_report)
        
        # JSON report for automation
        json_report = {
            'app_name': self.app_name,
            'generated_at': datetime.now().isoformat(),
            'combined_score': self._calculate_combined_score(),
            'quality_results': self.quality_results,
            'security_results': self.security_results,
            'summary_metrics': {
                'quality_score': self.quality_results.get('overall_score', 0),
                'security_risk_level': self.security_results.get('overall_risk_level', 'unknown'),
                'total_vulnerabilities': len(self.security_results.get('vulnerabilities', [])),
                'total_quality_issues': len(self.quality_results.get('findings', [])),
                'quality_checks_passed': self._count_quality_passes(),
                'quality_checks_failed': self._count_quality_failures()
            }
        }
        
        with open('review_results/reports/comprehensive_review_report.json', 'w') as f:
            json.dump(json_report, f, indent=2)
        
        print("✅ Review reports generated:")
        print("   📄 Executive Summary: review_results/reports/executive_summary.txt")
        print("   🌐 HTML Report: review_results/reports/detailed_review_report.html")
        print("   📊 JSON Report: review_results/reports/comprehensive_review_report.json")
        
        # Print summary to console
        print(summary)
        
        return {
            'summary': summary,
            'html_report_path': 'review_results/reports/detailed_review_report.html',
            'json_report': json_report
        }


def generate_comprehensive_reports():
    """Main function to generate comprehensive reports"""
    reporter = ComprehensiveReviewReporter('${input:app_name}')
    reports = reporter.generate_all_reports()
    return reports


if __name__ == '__main__':
    generate_comprehensive_reports()
```

## Main Review Execution Script

**Execute the complete review workflow:**

```bash
#!/bin/bash

# Execute complete review and scanning workflow
echo "=== EXECUTING COMPREHENSIVE REVIEW SCAN ==="

# Check prerequisites
if [ ! -d "review_checklists" ]; then
    echo "❌ Review checklists not found. Run prompt 07.1 first."
    exit 1
fi

# Setup directories
mkdir -p review_results/{quality,security,detailed,reports}

# Install security tools
echo "Installing security scanning tools..."
pip install bandit safety flake8 pydocstyle radon 2>/dev/null || echo "Tools already installed"

# Execute quality review
echo "Executing quality review..."
python review_execution/quality_reviewer.py

# Execute security scan
echo "Executing security scan..."
python review_execution/security_scanner.py

# Generate comprehensive reports
echo "Generating comprehensive reports..."
python review_execution/review_reporter.py

echo ""
echo "=== REVIEW EXECUTION COMPLETE ==="
echo "📊 Executive Summary: review_results/reports/executive_summary.txt"
echo "🌐 Detailed Report: review_results/reports/detailed_review_report.html"
echo "📄 JSON Report: review_results/reports/comprehensive_review_report.json"
echo ""
echo "Open the HTML report in your browser for detailed results."
```

## Success Criteria

**Review execution is successful when:**

✅ **All automated checks are executed successfully**  
✅ **Quality score is calculated and reported**  
✅ **Security vulnerabilities are identified and categorized**  
✅ **Comprehensive reports are generated in multiple formats**  
✅ **Actionable recommendations are provided**  
✅ **Risk levels are properly assessed**  
✅ **Integration with external security tools works**  
✅ **Results are saved for tracking and comparison**

---

**Note**: This prompt executes the automated reviews based on checklists from prompt 07.1 and provides comprehensive analysis with detailed findings and recommendations.